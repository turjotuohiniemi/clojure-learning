(max 1 nil)
(doc max)
(> 1 nil)
(> 1 false)
(doc nil?)
[1]
[(if true 1 0)]
[(if true [1 2 2 3] 0)]
(first [])
(count nil)
(def aseq [[1 2] [] [1 2 3]])
(first aseq)
(rest (aseq)
)
(rest aseq)
(first (rest aseq))
(rest (rest aseq))
(count (rest aseq))
(doc cons)
(cons 1 2)
(cons 1 '(2))
(cons 1 '(nil))
(cons 1 nil)
(map inc [1 2 3])
(doc remove)
(doc filter)
(filter true [1])
(filter (fn [x] true) [1])
(filter (fn [x] true) [nil])
(cons nil [])
(cons nil nil)
(doc cond)
(cond)
(cond 1 2
)
(cond 1 2 3 4)
(cond 2 3 4)
(cons 1 nil)
(doc map)
(map (fn [x] x) [1 2 3])
(map (fn [x] x) [1 2 3] [4 5 6])
(map (fn [x y] (+ x y)) [1 2 3] [4 5 6])
(doc apply)
(doc pow)
(doc sqrt)
(doc Math/sqrt)
Math/sqrt 1
(Math/sqrt 1)
(Math/sqrt 2)
NaN
(* nil nil)
(doc neg)
(* -2 -1)
(doc repeat)
(repeat 1 2)
(repeat 5 6)
(repeat 2 6)
(repeat -2 6)
(doc range)
(range 3)
(range -3)
(doc tails)
(doc reverse)
(doc seq)
(cons '() [])
(empty? nil)
(reverse [1 2 3])
(reverse [1 [1 2] 3])
(doc concat)
(doc first)
(doc range)
(range)
(range 5)
(doc repeat)
(doc first)
(doc n-first)
(doc first-n)
(doc freq)
(doc frequencies)
(+ nil 1)
(inc nil)
(doc contains?)
(doc assoc)
(assoc {} :key 2)
(assoc {:key 1} :key 2)
(assoc {:key 1 :hip hop} :key 2)
(assoc {:key 1 :hip "hop"} :key 2)
(:key {:key 1})
(def a "b")
(a {"a" 1})
(doc val)
(val a)
(val a {})
(doc some)
(doc get)
(doc map)
(map (fn [a b] [a b]) {:key 1))
(map (fn [a b] [a b]) {:key 1)
(map (fn [a b] [a b]) {:key 1})
(map (fn [a] [a]) {:key 1})
(map (fn [a] [a]) {:key 1 :joo 2})
(doc keys)
(doc concat)
(doc assoc)
(doc cons)
(cons 1)
(cons 1 '())
(doc get)
(doc repeat)
(doc conj)
(conj '(1) '(2 3))
(doc cons)
(doc next)
(doc rest)
(doc nnext)
(doc flatten)
(flatten '('(1 2) '(1 2 3)))
(flatten [[1 2] [4 5 6]])
(flatten [[1 2] [4 5 6 2]])
(empty? {})
(first {:key 1})
(first {:key 1 :hei 2})
(keys (first {:key 1 :hei 2}))
(get (first {:key 1 :hei 2}) 1)
(get (first {:key 1 :hei 2}) 0)
(doc repeat
)
(doc get)
(doc repeat)
(def a {:a 3})
(first a)
(get (first a) 0)
(get (first a) 1)
(repeat (get (first a) 0) (get (first a) 1)
)
(doc repeat)
(repeat :key 3)
(repeat ":key" 3)
(repeat 3 :key)
(doc take)
(doc last)
(doc drop)
(doc sort)
(< nil 1)
(< () 1)
(< '() 1)
(doc cons)
(cons '() [])
(cons nil [])
(doc concat)
(sort [2 1]9
(sort [2 1])
(sort [nil])
(sort [nil nil])
(sort [4 nil nil])
(first [])
(nil? (first []))
(rest [])
(cons (first []) (rest []))
(doc empty?)
(doc seq)
(doc false)
(sort [false nil 9 5])
(sort [nil 9 5])
(int false)
(doc take-while)
(doc drop)
(doc inits)
(doc num)
(num 1)
(doc cmp)
(sort [nil false])
(sort [nil false nil])
(doc num)
(num nil)
(num false)
(compare false false)
(compare false nil)
(compare false 0)
(sort [0 false])
(sort [nil false])
(doc empty)
(doc empty?)
(doc take)
(doc drop)
(first (rest []))
(def a (first []))
a
(nil? a)
(false? a)
(empty? nil)
(first [])
(compare (first []) (first [2]))
(sort [nil 9 6 3 nil false])
(sort [nil 9 6 nil 3 nil false])
(sort [nil nil false])
(sort [1 false])
(sort [1 nil])
(doc keys)
(keys #{1 5 3})
(values #{1 5 3})
(vals #{1 5 3})
(first #{1 5 3})
(first #{:ahaa 1 5 3})
(first #{:ahaa 5 3})
(first #{:ahaa})
(keys (seq #{1 5 3}))
(doc elements)
(doc elems)
(doc clojure.set/index)
(doc zipmap)
(doc map)
(range 0 9)
(map (fn [x] x) (range 0 9))
(map (fn [x] (inc x)) (range 0 9))
(map (fn [x] (-x)) (range 0 9))
(map (fn [x] (- x)) (range 0 9))
(if (or true (map (fn [x] (- x)) (range 0 9))) "jees!" "pöh")
(if (or true (map (fn [x] (- x)) (range 0 99999))) "jees!" "pöh")
(if (or true (map (fn [x] (- x)) (range 0 9999999))) "jees!" "pöh")
(if (or true (map (fn [x] (- x)) (range 0 99999999999999))) "jees!" "pöh")
(if (or true (map (fn [x] (- x)) (range 0 99999))) "jees!" "pöh")
(if (or false (map (fn [x] (- x)) (range 0 99999))) "jees!" "pöh")
(if (or false (map (fn [x] false) (range 0 99999))) "jees!" "pöh")
(if (or false (map (fn [x] false) (range 0 999999))) "jees!" "pöh")
(if (or false (map (fn [x] false) (range 0 9999999))) "jees!" "pöh")
(if (or false (map (fn [x] false) (range 0 99999999))) "jees!" "pöh")
(doc some)
(doc some?)
(doc any)
(doc any?)
(def aset #{3 8 5 :hoi "moi"})
(doc aset)
(def a #{3 8 5 :hoi "moi"})
a
(keys a)
(seq a)
(get (seq a) 0)
(get (seq a) 1)
(doc get)
(doc a 0)
(get a 0)
(get a 1)
(seq a)
(get (seq a) 1)
(doc get)
(def b ("a" "b" "c"))
(def b '("a" "b" "c"))
(get b 1)
b
(get b 0)
(doc array)
(def b ["a" "b"])
(get b 1)
(doc get)
(doc peek)
(doc time)
(time 0)
(doc index)
(doc clojure.set/index)
(doc join)
a
(keys a)
(vals a)
(first a)
a
(rest a)
(map 0 a)
(map (fn [x] x) a)
(doc assoc)
(doc vector)
(vector a)
(empty? #{})
(empty? #{nil})
(empty? #{nil false})
(doc count)
(range 0 1)
(range 0 0)
(map (fn [k] k) (range 0 0))
(doc assoc)
(assoc [4 5 6] 0 1)
(doc conj)
a
b
(def b ["eka" "toka" "kolmas"])
(conj b (get b 1))
(assoc b (get b 1))
(doc assoc)
(doc concat)
(doc conj)
(doc nth)
(doc take)
(doc concat)
(doc vec)
(doc vector)
(doc flatten)
(doc conj)
(doc concat)
(last '[[:c]])
(first '[[:c]])
(last '[:c])
(doc last)
(doc first)
(doc rest)
(doc vec)
(vec #{:a})
(list #{:a})
(= nil nil)
(= nil false)
(= false false)
(empty? nil)
(empty? '(nil))
(range 0)
(doc conj)
(conj #{} '())
(conj #{} '(:a))
(conj #{:b} '(:a))
(set #{})
(set #{:b})
(doc set)
(set (set #{:b}))
(def a #{})
(conj a a)
(def a #{:ahaa})
(conj a a)
(conj a #{})
(conj #{} #{})
(doc empty)
(doc set)
(doc assoc)
(doc conj)
(doc set)
(set :a)
(set (seq :a))
(set '(:a))
(doc conj)
(conj :a #{})
(doc assoc)
(conj :a #{})
(conj (set :a) #{})
(conj #{:b} #{})
(conj #{:b} #{:a})
(doc conj)
(set (seq :a))
(seq :a)
(set :a)
(conj #{} :a)
